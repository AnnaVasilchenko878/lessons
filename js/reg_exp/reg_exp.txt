Регулярные выражения - это шаблоны класса RegExp для поискка, манипуляций, сопоставления подстрок.

Где используют?

- валицация форм
- обработка текстовых данных 
- поиск и фильтрация текстовых данных

Как это работает?
Класс RegExp позволяет создать объект с методами которые работают с регулярными выражениями, далее в объект передается шаблон затем в метод передается строка.

let переменная = /выражение/;
переменная.название_метода(строка);

Преимущества

+ Гибкость, сопоставление по широкому критерию (регистр, все совпадения, сложные комбинации)
+ Многократное использование
+ Высокая производительность


Недостатки

- плохая читабельность кода
- ограниченое количество методов
- небольшая сложность в основении

Терминология:

1. Шаблон регулярного выражения - это комбинация символьных классов через которую осуществляется манипуляции над строками

2. Символьный класс - наименьшая единица от конструкции для манипуляции над строками

3. Наборы символьных классов - комбинации символьных единиц.

4. Квантификаторы регулярных выражений - это специальные символы которые указывают сколько раз должна повторяться нужная комбинация символов или одтельный символ.

5. Флаги - это символы модификаторы которые добавляют в шаблон для расширеного поиска совпадений 

6. Юникодное свойство - символьный класс, который использует синтаксис Unicode Properties Escape, для разных символов и других языков

7. Якорь - символ который указывает на порядок в условии поиска совпадений

Особенности:
- некоторые символы нужно экранировать, иначе они могут восприниматься как флаг
- символьные наборы записываются без пробелов
- символьный класс \w выполняется над латинскими буквами
- следует внимательно писать шаблоны где похожие буквы на разных языках
- в наборах с дипазонам символы считываются с учетом кодировки UTF-8 поэтому некоторые символы не будут входить (например буква "ё" - 1105 в кириллице а я - 1103)
- квантификаторы бывают жадными, они забирают максимальное количество совпаднний в диапазоне (например {3,4} результат по 4 совпадениям)
- ленивые квантификаторы выбирают наименьшее совпадение в диапазоне
- если в строке есть символы имеющие больше совпадений чем шаблон с диапазоном то выбранный символ вырезается по шаблону (например если шаблон состоит из цифр имеющих порядок совпадений 2 или 3, а втроке есть число 5689, то результат будет 568)
- для получение полной информации из метода matchAll необходимо результат превратить в массив
- регулярные выражения работают как с методами класса String так и с RegExp классом
- якорь границы слова выполняется над латинскимим символами
- юникодные свойства перечисленны в таблице
- границы слова на могут стоять вначале или в конце, так же обрамлять символ
- при валидации формы нужно ставить якоря на ограничение символов по количеству

Создать регулярное выражение
1. Как экземпляр класса
  let varName = new RegExp('шаблон', 'флаги');
  
2. Через литерал обратных слешей
  let varName = /шаблон/флаги

Символьные классы - классы которые определяют набор символов
\d - символ цифры от 0 до 9

Найти число в строке от 0-9
let reg = /\d/;

Найти любой первый символ кроме числа
let reg =/D/;

Найти первый пробел, табуляция, конец файла, перенос строки
let reg = /\s/

Найти непробельный символ
let reg = \/S\;

Найти нижнее подчеркивание или любую цифру 0-9, или латинский символ
let reg = \/w\;

Найти не символ, не цифру, не нижнее подчеркивание
let reg = /\w/;

Найти первый символ из набора символьных классов 
let reg = /[перечисление символов без пробела]/

Найти первую подстроку из набора
let reg = /[символы варианты начала подстроки без пробела]конец строки/

Найти подстроку с некоторыми исключениями
let reg = /[^символы исключения]/

Найти символьный диапазон
let reg = /[начало символа - конец символа]/

Найти символ который не входит в диапазон набора
let reg = /[^символ начала - символ конца дипазона]/

Найти символ который повторяется, либо последовательность
let reg = /символ{кол-во повторений}/

Найти символ который может повторяться опрелеленное количество раз 
let reg = /символ{кол-во повторений, кол-во повторений}/

Найти минимальный набор символов который повторяется
let reg = /символ{ко-во повторений, кол-во повторений}?/ 

Найти количество повторений от и до бесконечности
let reg = /символ{кол-во повторений,}/

Найти минимальное количество повторений от и до бесконечности
let куп = /символ{кол-во повторений,}?/;

Найти символ с условием 
let reg = /символ?символ/

Найти максимальное количество совпадений от нуля
let reg = /символ*/

Найти минимальное количество совпадений 
let reg = /символ*?/

Найти максимальное количество совпадений от 1 и до бесконечности
let reg =/символ+/ 

Методы
Получить данные о совпадении
строка.match(регулярное выражение)

Получить данные о первом совпадении 
шаблон.exec(строка)

Отредактировать строку по шаблону
строка.split(шаблон)

Узнать индекс первого совпадения, (-1 если нет совпадений)
строка.search(шаблон)

Узнать итератор совпадений
строка.matchAll(шаблон)

Перевести итератор совпадений в массив
Array.from(строка.matchAll(шаблон))

Узнать соответствует ли строка шаблону 
шаблон.test(строка)

Флаги 
Найти все совпадения символов
let reg = /символ/g

Найти абсолютно все совпадения включая перевод строки
let reg = /./gs

Найти первый символ и больше не искать
let reg = /символ/y

Найти символ юникод
let reg = /\p символ/u;

Найти первый символ строки 
let reg = /^символ/

Найти последний символ
let reg = /символ$/

Найти символ на каждой строке
let reg = /символ/m

Найти полный символ исключив часть (hi => hi hi!=>hit)
let reg = /\bсимвол\b/

Найти символ который является частью слова
let reg = /\Bсимвол\B/